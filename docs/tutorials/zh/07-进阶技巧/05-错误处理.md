# æ¨¡å— 5: é”™è¯¯å¤„ç†

> å®ç°å¥å£®çš„é”™è¯¯å¤„ç†

## ç»Ÿä¸€é”™è¯¯å¤„ç†

```javascript
// é”™è¯¯ç±»å‹å®šä¹‰
class AppError extends Error {
  constructor(message, statusCode, code) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = true;
  }
}

class ValidationError extends AppError {
  constructor(message, field) {
    super(message, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

class AuthError extends AppError {
  constructor(message) {
    super(message, 401, 'AUTH_ERROR');
  }
}

// é”™è¯¯å¤„ç†å™¨
class ErrorHandler {
  static handle(error) {
    if (error.isOperational) {
      return this.handleOperationalError(error);
    }
    return this.handleProgrammerError(error);
  }
  
  static handleOperationalError(error) {
    const message = this.getUserMessage(error);
    this.showNotification(message, 'error');
    console.error('[Operational Error]', error);
  }
  
  static getUserMessage(error) {
    const messages = {
      'VALIDATION_ERROR': `è¾“å…¥éªŒè¯å¤±è´¥: ${error.message}`,
      'AUTH_ERROR': 'è®¤è¯å¤±è´¥,è¯·é‡æ–°ç™»å½•',
      'NOT_FOUND': 'è¯·æ±‚çš„èµ„æºä¸å­˜åœ¨'
    };
    return messages[error.code] || 'æ“ä½œå¤±è´¥,è¯·ç¨åé‡è¯•';
  }
}

// å…¨å±€é”™è¯¯æ•è·
window.addEventListener('error', (event) => {
  ErrorHandler.handle(event.error);
});

window.addEventListener('unhandledrejection', (event) => {
  ErrorHandler.handle(event.reason);
});
```

## API è¯·æ±‚é”™è¯¯å¤„ç†

```javascript
class APIClient {
  async request(endpoint, options = {}) {
    let lastError;
    
    for (let attempt = 0; attempt < 3; attempt++) {
      try {
        const response = await Promise.race([
          fetch(url, options),
          this.timeoutPromise(10000)
        ]);
        
        if (!response.ok) {
          throw await this.handleHTTPError(response);
        }
        
        return await response.json();
      } catch (error) {
        lastError = error;
        
        if (!this.shouldRetry(error, attempt)) {
          break;
        }
        
        await this.delay(1000 * (attempt + 1));
      }
    }
    
    throw lastError;
  }
  
  shouldRetry(error, attempt) {
    if (attempt >= 2) return false;
    if (error.message === 'Request timeout') return true;
    if (error.statusCode >= 500) return true;
    return false;
  }
}
```

## å…³é”®è¦ç‚¹

1. **é”™è¯¯åˆ†ç±»** - åŒºåˆ†å¯é¢„æœŸå’Œä¸å¯é¢„æœŸé”™è¯¯
2. **ç”¨æˆ·å‹å¥½** - æ˜¾ç¤ºæ˜“æ‡‚çš„é”™è¯¯æ¶ˆæ¯
3. **æ—¥å¿—è®°å½•** - è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
4. **é‡è¯•æœºåˆ¶** - å¯¹ä¸´æ—¶é”™è¯¯è¿›è¡Œé‡è¯•

ğŸ‘‰ ä¸‹ä¸€ä¸ª: [æ¨¡å— 6: å®‰å…¨æœ€ä½³å®è·µ](./06-å®‰å…¨å®è·µ.md)
